# 树

## 树的一些基本概念

1. N个节点的树有N-1条边
2. 没有儿子的节点叫做树叶
3. 一棵树从根节点到任意一个节点恰好存在一条路径
4. 对于节点的深度,为从根节点到该节点的路径长度
5. 一个节点的高为从该节点到一片树叶的最长路径的长度,一个树的高为根节点的高
6. 一棵树的所有节点的深度和称为内部路径长
7. 一个树的深度等于它最深的树叶的深度,这个深度与树的高相等
8. 如果从n1到n2存在一条路径,那么n1是n2的一位祖先

### 树的实现

由于每个节点的儿子的变化很大,所以让每个节点指向它的各个儿子不太现实,所以使用下面的办法

```.c
typedef struct TreeNode* PtrToTree

struct TreeNode{
    ElementType Elemnet;
    PtrToTree FirstChild;  //节点的第一个儿子
    PtrToTree NextSibling;  //节点的下一个兄弟
}
```

### 树的遍历与应用

#### 先序遍历

处理y一个节点在他所有子节点之前

#### 后序遍历

处理一个节点在它所有子节点之后

## 二叉树

每个节点不能有多与两个的儿子,它的平均深度为O(sqrt(N)),**二叉查找树**的平均深度为O(logN)

### 二叉树的实现

一个二叉树最多只有两个儿子,所以可以使用,两个指针来分别指向,这和双链表类似.**具有N个节点的二叉树,需要N+1个NULL指针.**

### 表达式树--二叉树的应用

将一个后缀表达式转换成一个二叉树

## 查找树ADT--二叉查找树

对于树中的每个节点,它的左子树中所有的关键字小于它,而右子树的所有值大于它,  
**这意味着,这棵树的所有元素可以使用某种统一的方式排序**  
  
下面给出一些二叉查找树的一些难实现的操作,由于树的递归定义,我们一般递归的编写例程

> **Delete**  

这个操作主要用于删除一个节点  
有三种情况

* **节点是一个树叶**:直接查找之后删除
* **节点有一个子节点**:找到父节点,改变父节点的指针再删除
* **节点有两个子节点**:这是最复杂的情况,用其右子树的最小数据来代替该节点的数据,并且递归的删除这个节点,,右子树的最小节点不可能有左儿子,所以删除起来就变成了第二种情况.但是这样做效率并不高,因为它延该树两次搜索,查找和删除,右子树的最小节点
* 时间复杂度为O(logN)

### Note

* 假设所有的树出现的机会相等,那么树的所有节点的平均深度为O(logN)  
* 对于上面所实现的删除算法,有助于左子树比右子树深,因为每次都是拿右子树的最小来代替删除节点,因此为了平衡左右子树,我们可以随机选择**左子树的最大值**或者**右子树的最小值**来代替删除节点
* 如果一棵二叉查找树一开始就是排好序的,那么每个节点都没有左子树,这时的树就是一个链表,有序插入的代价很大,**所以为二叉查找树增加一个平衡条件:节点的深度不得过深**

## 平衡查找树--AVL树

一棵AVL树是要求其每个节点的左子树和右子树高度最多差1的二叉查找树(**空树的高度定义为-1**)  
当进行插入操作时,我们需要更新新节点通向根节点上那些所有节点的所有平衡信息,一个插入操作可能会破坏一棵AVL树的平衡性,这时我们需要**旋转**来平衡新的树  
  
插入的不平衡的可能性出现在以下四种情况

1. 对a的左儿子的左子树进行一次插入
2. 对a的左儿子的右子树进行一次插入
3. 对a的右儿子的左子树进行一次插入
4. 对a的右儿子的右子树进行一次插入

我们对于第1,4使用`单旋转`的方法恢复 (插入在外边)  
对于2,3使用`双旋转`恢复(插入在内部)

### 单旋转与双旋转

结合代码,看图很容易理解,这里不再赘述

### 插入

首先要明确,树是递归定义的,寻找要插入的位置也是递归进行查找,当找到对应的位置的时候,malloc一块空间,然后把节点返回到上一级递归,对于当插入导入失衡的时候,如何判断是上述四种情况的哪一种,  
至于如何判断失衡的时候是左子树高还是右子树高,用二者的高进行比较,这个方法还可以判断是否失衡(Heigth(左)-Heigth(右))  
根据当前节点的左右子树的值与待插入值的大小进行比较得出,  
最后,当节点插入成功后,不要忘了更新各个节点的高度(**只有沿着插入路径上的节点的高度才会改变**),  
对于每个节点更新高度的方法:

>比较左子树和右子树的高低,高的加1就是此节点的高度

### 删除

平衡二叉树的删除和一般的二叉树差不多,就是再删除之后,要判断节点是否失衡  
简单来说也是比较左右子树的高低,高度差为2的时候失衡  
至于如何判断失衡的时候是上面四种的哪种情景,  
根据此节点**左子树的左子树和右子树的高低**或者**右子树的左子树和右子树的高低**来判断

### Notic

对于破话平衡的上述四种方法,无论是哪一种,都要先找到**最先失去平衡的节点**,即最先左子树和右子树的高度相差超过1的节点(从树的下面开始往上找),然后把此节点当做旋转的根节点(不是整棵树的根节点),然后再根据上面四种情景来进行单旋转或者双旋转  
判断是上面四种的哪一种,也是基于最先失去平衡的节点

## B-树(待续,更新)

到现在来看,我们所看到的查找树都是二叉树,但是也有一些不是二叉树的查找树,我们把他们叫做**B-树**

阶为M的B-树具有以下结构特性

* 除根节点外,其他非树叶节点的儿子数在M/2到M之间
* 所有的树叶在相同深度上
* 所有的数据都储存在树叶上,根节点和其他节点没有数据
* 对于根节点和树叶,其儿子数在2到M之间,树叶的儿子可以看做树叶里面所存储的关键字的个数

在每一个内部节点都含有指向**该节点各个儿子的指针**p1,p2,p3,p4.....和**每个子树中的最小关键值**,当然有些指向儿子的指针是NULL,那么其对应的最小关键值就是未定义的,要注意与二叉查找树一样,p1子树上的值小于p2子树,p2字子树上的值小与p3子树,等等  
(还有一种B-树是允许内部节点存储数据)

一棵B树的最深的深度为o(log[M/2]N),(中括号内为底数)  
在路径上的每个节点,我们使用O(logM)的时间来确定选择哪个分支(这边查找)  
但是插入和删除操作需要O(M)的时间来调节节点的信息  
查找操作一次只花费O(log N)的时间(O(logM * log[M/2]N),M是常数

下面的讨论都是基于3阶的B-树

### 插入-Insert

像一般二叉树一样,都要先通过与各个节点之间的比较来确定最终的插入位置,这个位置肯定是在树叶的地方,如果插入之后使得树叶有四个儿子,超过了3叉树的要求,就需要把四个儿子拆为两个节点,每个节点都是该树叶父节点的一个新儿子,而且这两个节点每个节点都有两个儿子,这样做会使父节点的儿子数增加一个,如果这时父节点的儿子数也变成了四个,那么继续用以上的方法进行拆分,直到拆分之后的父节点的儿子个数小于等于三个,**不要忘了插入之后更新每个内部节点的信息**  
还有一种方法,就是找到插入位置的时候,如果当前树叶的儿子数是三个,可以查找这个树叶的只有两个儿子的兄弟,如果兄弟节点有没有满三个节点的,然后将这个树叶的一个儿子移到其兄弟上,然后再进行插入,这样就不用上面那种麻烦的一直分裂,如果兄弟也都满了,那么就在进行上面的分裂**同样不要忘了更新节点信息**

### 删除-Delete

删除相对于插入来说较为简单,找到要删除的数的位置,然后删除就可以,不过要注意,当要删除的节点是这个树叶的唯一节点的时候,删除后要更新这个树叶父节点的信息,如果删除后,这个树叶和兄弟树叶的儿子数目小于3

[参考](https://blog.csdn.net/xiaohusaier/article/details/76708490#commentBox)