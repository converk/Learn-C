# 树

## 树的一些基本概念

1. N个节点的树有N-1条边
2. 没有儿子的节点叫做树叶
3. 一棵树从根节点到任意一个节点恰好存在一条路径
4. 对于节点的深度,为从根节点到该节点的路径长度
5. 一个节点的高为从该节点到一片树叶的最长路径的长度,一个树的高为根节点的高
6. 一棵树的所有节点的深度和称为内部路径长
7. 一个树的深度等于它最深的树叶的深度,这个深度与树的高相等
8. 如果从n1到n2存在一条路径,那么n1是n2的一位祖先

### 树的实现

由于每个节点的儿子的变化很大,所以让每个节点指向它的各个儿子不太现实,所以使用下面的办法

```.c
typedef struct TreeNode* PtrToTree

struct TreeNode{
    ElementType Elemnet;
    PtrToTree FirstChild;  //节点的第一个儿子
    PtrToTree NextSibling;  //节点的下一个兄弟
}
```

### 树的遍历与应用

#### 先序遍历

处理y一个节点在他所有子节点之前

#### 后序遍历

处理一个节点在它所有子节点之后

## 二叉树

每个节点不能有多与两个的儿子,它的平均深度为O(sqrt(N)),**二叉查找树**的平均深度为O(logN)

### 二叉树的实现

一个二叉树最多只有两个儿子,所以可以使用,两个指针来分别指向,这和双链表类似.**具有N个节点的二叉树,需要N+1个NULL指针.**

### 表达式树--二叉树的应用

将一个后缀表达式转换成一个二叉树

## 查找树ADT--二叉查找树

对于树中的每个节点,它的左子树中所有的关键字小于它,而右子树的所有值大于它,  
**这意味着,这棵树的所有元素可以使用某种统一的方式排序**  
  
下面给出一些二叉查找树的一些难实现的操作,由于树的递归定义,我们一般递归的编写例程

> **Delete**  

这个操作主要用于删除一个节点  
有三种情况

* **节点是一个树叶**:直接查找之后删除
* **节点有一个子节点**:找到父节点,改变父节点的指针再删除
* **节点有两个子节点**:这是最复杂的情况,用其右子树的最小数据来代替该节点的数据,并且递归的删除这个节点,,右子树的最小节点不可能有左儿子,所以删除起来就变成了第二种情况.但是这样做效率并不高,因为它延该树两次搜索,查找和删除,右子树的最小节点
* 时间复杂度为O(logN)

### Note

* 假设所有的树出现的机会相等,那么树的所有节点的平均深度为O(logN)  
* 对于上面所实现的删除算法,有助于左子树比右子树深,因为每次都是拿右子树的最小来代替删除节点,因此为了平衡左右子树,我们可以随机选择**左子树的最大值**或者**右子树的最小值**来代替删除节点
* 如果一棵二叉查找树一开始就是排好序的,那么每个节点都没有左子树,这时的树就是一个链表,有序插入的代价很大,**所以为二叉查找树增加一个平衡条件:节点的深度不得过深**

## 平衡查找树--AVL树

一棵AVL树是要求其每个节点的左子树和右子树高度最多差1的二叉查找树(**空树的高度定义为-1**)  
当进行插入操作时,我们需要更新新节点通向根节点上那些所有节点的所有平衡信息,一个插入操作可能会破坏一棵AVL树的平衡性,这时我们需要**旋转**来平衡新的树  
  
插入的不平衡的可能性出现在以下四种情况

1. 对a的左儿子的左子树进行一次插入
2. 对a的左儿子的右子树进行一次插入
3. 对a的右儿子的左子树进行一次插入
4. 对a的右儿子的右子树进行一次插入

我们对于第1,4使用`单旋转`的方法恢复 (插入在外边)  
对于2,3使用`双旋转`恢复(插入在内部)

### 单旋转与双旋转

结合代码,看图很容易理解,这里不再赘述

### 插入

首先要明确,树是递归定义的,寻找要插入的位置也是递归进行查找,当找到对应的位置的时候,malloc一块空间,然后把节点返回到上一级递归,对于当插入导入失衡的时候,如何判断是上述四种情况的哪一种,  
至于如何判断失衡的时候是左子树高还是右子树高,用二者的高进行比较,这个方法还可以判断是否失衡(Heigth(左)-Heigth(右))  
根据当前节点的左右子树的值与待插入值的大小进行比较得出,  
最后,当节点插入成功后,不要忘了更新各个节点的高度(**只有沿着插入路径上的节点的高度才会改变**),  
对于每个节点更新高度的方法:

>比较左子树和右子树的高低,高的加1就是此节点的高度

### 删除

平衡二叉树的删除和一般的二叉树差不多,就是再删除之后,要判断节点是否失衡  
简单来说也是比较左右子树的高低,高度差为2的时候失衡  
至于如何判断失衡的时候是上面四种的哪种情景,  
根据此节点**左子树的左子树和右子树的高低**或者**右子树的左子树和右子树的高低**来判断

### Notic

对于破话平衡的上述四种方法,无论是哪一种,都要先找到**最先失去平衡的节点**,即最先左子树和右子树的高度相差超过1的节点(从树的下面开始往上找),然后把此节点当做旋转的根节点(不是整棵树的根节点),然后再根据上面四种情景来进行单旋转或者双旋转  
判断是上面四种的哪一种,也是基于最先失去平衡的节点