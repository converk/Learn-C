# 树

## 树的一些基本概念

1. N个节点的树有N-1条边
2. 没有儿子的节点叫做树叶
3. 一棵树从根节点到任意一个节点恰好存在一条路径
4. 对于节点的深度,为从根节点到该节点的路径长度
5. 一个节点的高为从该节点到一片树叶的最长路径的长度,一个树的高为根节点的高
6. 一棵树的所有节点的深度和称为内部路径长
7. 一个树的深度等于它最深的树叶的深度,这个深度与树的高相等
8. 如果从n1到n2存在一条路径,那么n1是n2的一位祖先

### 树的实现

由于每个节点的儿子的变化很大,所以让每个节点指向它的各个儿子不太现实,所以使用下面的办法

```.c
typedef struct TreeNode* PtrToTree

struct TreeNode{
    ElementType Elemnet;
    PtrToTree FirstChild;  //节点的第一个儿子
    PtrToTree NextSibling;  //节点的下一个兄弟
}
```

### 树的遍历与应用

#### 先序遍历

处理y一个节点在他所有子节点之前

#### 后序遍历

处理一个节点在它所有子节点之后

## 二叉树

每个节点不能有多与两个的儿子,它的平均深度为O(sqrt(N)),**二叉查找树**的平均深度为O(logN)

### 二叉树的实现

一个二叉树最多只有两个儿子,所以可以使用,两个指针来分别指向,这和双链表类似.**具有N个节点的二叉树,需要N+1个NULL指针.**

### 表达式树--二叉树的应用

将一个后缀表达式转换成一个二叉树

## 查找树ADT--二叉查找树

对于树中的每个节点,它的左子树中所有的关键字小于它,而右子树的所有值大于它,  
**这意味着,这棵树的所有元素可以使用某种统一的方式排序**  
  
下面给出一些二叉查找树的一些难实现的操作,由于树的递归定义,我们一般递归的编写例程

> **Delete**  

这个操作主要用于删除一个节点  
有三种情况

* **节点是一个树叶**:直接查找之后删除
* **节点有一个子节点**:找到父节点,改变父节点的指针再删除
* **节点有两个子节点**:这是最复杂的情况,用其右子树的最小数据来代替该节点的数据,并且递归的删除这个节点,,右子树的最小节点不可能有左儿子,所以删除起来就变成了第二种情况.但是这样做效率并不高,因为它延该树两次搜索,查找和删除,右子树的最小节点
* 时间复杂度为O(logN)

### Note

* 假设所有的树出现的机会相等,那么树的所有节点的平均深度为O(logN)  
* 对于上面所实现的删除算法,有助于左子树比右子树深,因为每次都是拿右子树的最小来代替删除节点,因此为了平衡左右子树,我们可以随机选择**左子树的最大值**或者**右子树的最小值**来代替删除节点
* 如果一棵二叉查找树一开始就是排好序的,那么每个节点都没有左子树,这时的树就是一个链表,有序插入的代价很大,**所以为二叉查找树增加一个平衡条件:节点的深度不得过深**

## 平衡查找树--AVL树