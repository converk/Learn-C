# 图论算法

1. 给出一些算法解决普通的图论问题
2. 选择合适的数据结构来减少算法的运行时间
3. 深度优先搜索与广度优先搜索

## 定义

G=(V,E),G代表一个图,V是顶点的集合,E是边的集合,每一条边又是两个顶点的集合`e=(v,w)`,  
`一条路径`就是多个连在一起顶点的集合,如果一个顶点有到它自身的路径,那么这条路径一般也叫作**环**,我们要讨论的图一般是无环的,  
**简单路径**: 路径上的所有顶点都是互异的,除了第一个顶点和最后一个顶点可能相同  
**有向图中的圈**: 满足`w1=wN`,即第一个顶点和最后一个顶点相同,并且路径的长度至少为1的简单路径,如果一个有向图中没有圈那么就称这个图为`无圈图(DAG)`,  
**连通**: 在**无向图**中,每个节点到每个其他节点间都存在一条路径,
**强连通的**: 具有连通性质的**有向图**称为强连通的
**弱联通的**: 如果一个有向图去掉方向变为无向图后是连通的,那么这个有向图称为弱连通的
**基础图**: 如果一个有向图不是强连通的,那么称为基础图
**完全图**: 任意两个顶点间都有一条路径

## 表示

可以使用一个二维数组来表示各个顶点之间的的关系(是否直接连接),对于有向图而言,边(a,b),说明从顶点a到顶点b有一条路径,那么直接就另A[a][b]为1,如果是无向图,在另A[b][a]为1,所以无向图的空间使用大约是有向图的两倍,但是如果顶点之间相互连接的比较少,但是二维数组的空间又是确定的,这样就会造成大量的空间浪费,所以采用了一种新的办法: 邻接表  
这个表来记录一个顶点与其它顶点之间直接相连的情况,其实也就是多个链表,每一个链表的头结点是这个顶点的关键字,指针指向下一个与它直接相连的顶点,在这种情况下,无向图的空间使用依旧是有向图的两倍  
但是在实际情况中,图的顶点的关键字并不是数字而是字符串,为了存储和访问的方便,邻接表里面存储的都是使用数字来表示的图的顶点,如果直接使用名字来存储的话,如果名字过长,那么所使用的空间也会很大  
所以,必须有一中方式储存一个名字到对应数字的映射,容易想到的就是一个散列表,  
当读入一个图的时候,每进来一条边,检查它的两个顶点是否已经在散列表里面,如果不在的话,给这个顶点指定一个数字编号(这个编号是在对图的操作中要用到的),并将这个顶点的名字和其对应的编号存储在散列表里面,如果顶点在散列表中,那么就直接略过,  
但是当我们对图进行操作完成的时候,返回的不能是数字编号,而是对应的名字,因此还需要存储数字和对应字符串的关系(注意:这里与上面散列的作用不同,散列的优点在于查找和插入都很快,适合用于寻找是否已插入,这里的目的是为了给编号回复相应的名字,也就是说需要遍历,这里使用散列就不太合适,当然也可以),可以维护一个字符串数组,对应索引对应相应的顶点名称

## 拓扑排序(对有向图而言)

首先,对于有向图里面的一个路径(u,v),在拓扑排序里面节点u一定要排在v的前面

### 基本的想法

先根据图的所有边算出所有节点的1入度(指向该节点的箭头),放入一个Indegree的数组中(图的每一个顶点由数字编号表示),先遍历Indegree数组,找出入度为0的节点,将该节点从图中删除,并且将这个节点放入一个队列中,当这个队列不为空的时候就出队,保证了进入队列的节点出队的时候顺序还是一样的,达到排序的目的,并且遍历该节点的邻接表,将所有与这个节点相连的节点的入度减一,并且判断这些节点的度减一之后是否为0,如果为0就入队.出队的时候使用一个topnum[size]来接受出队元素,并标记其是第几个出队的  
如果最终topnum不等于图中节点的个数,那么就说明图中有环

### 伪代码实现

```.c
void TopSort(Graph G){
    Queue Q; //队列
    Q=CreateQueue(size);
    MakeEmpty(Q)

    Node V;  //图的节点
    Node M;  //用来表示邻接表中的节点
    ArrayList W; //邻接表

    int count=0;  //出队顺序,也是最终排序结果

    for G to V
        if(Indegree[V]==0)
            Enqueue(V,Q);  //入队

    while(!Empty(Q)){  //当Q不为空的时候
        V=Dequeue(Q);  //出队

        topnum[V]=++count;

        for W[V] to M
            if(--Indegree[M]==0)
                Enqueue[M,Q]
    }

    if(count!=size)   //如果最终已经排序的个数小于图的节点数,那么就说明有圈
        fetalerror("The Graph has a cycle")
}
```

## 最短路径算法

只考虑单个节点到图的其他节点的路径的最小值,对于图的最短路径分析,有四种情况

1. 无权图--各个边没有权重
2. 赋权图--边有权重
3. 负边图--边值的权重有负数的情况
4. 无圈图--没有圈的图

### 无权图

对于无权图,最短路径就是一个顶点到另一个顶点的最少边数,也可以看作把所有边权值都看成1