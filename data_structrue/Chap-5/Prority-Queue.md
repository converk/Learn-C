# 优先队列

## 模型与应用

**优先队列**最少有两种操作,一种是插入一个进程(_Insert_)相当于入队,另外一种是删除最小的(_DeleteMin_)相当于出队

1. 操作系统的调度程序,操作系统必须使用一种数据结构来调度进程,调度的方法,要取决于进程占用的时间,进程的重要性等等`因素,不能光依赖于先进先出的队列原则
2. 对于之后的一些排序算法也很重要
3. 对于一些重要的算法,比如**贪婪算法**,很重要

## 实现

可以选择使用链表,二叉查找树实现,但是二叉查找树太过繁琐,它支持的功能对于优先队列来说有点多余,因此,这里采用一种在最坏的情况下**插入和查找**的复杂度都是**O(logN)**的数据结构

## 二叉堆

一般简称为**堆**,它具有两个性质: **结以至于不需要使用指针就可以实现构性**和**堆序性**,与AVL树一样,对堆的插入和删除操作都可能破坏上面两个性质,同样,对堆的操作只有上面两个性质完全满足之后才会停止

### 结构性质

二叉堆是一个被完全填满的二叉树,最有可能例外的是在最后一层,最后一层可能不是满的,但必须是从左到右插入元素,即,如果最后一层的一个节点为空,那么它右边(同一层的右边)一定不能有节点.  
堆的分布很有规律,,可以简单的使用一个数组来实现一棵完全二叉树:

> 对于一个根节点位于一个数组索引为1的完全二叉树,假设一个节点的索引为**i**,那么它的左儿子的索引为`2*i`,右儿子的索引为`2*i+1`,它的父亲的位置在`i/2`(整除)

上面的规律只限于对堆进行**层序遍历存储**,但是有一个缺点就是堆的大小必须事先给定,但是这个无伤大雅.

### 堆序性质

如果想要最快的找到最小值,最好的办法就是把最小值放在根节点上,那如果我们再假设,一个堆的任意子树也是一个堆那么就有:

> 在一个堆中,任意节点X的父亲的关键字的值总是节点节点X的关键字值

## 各种操作

### 插入

对于二叉堆的插入算法很简单,就是在整个堆的最后面新建一个空穴,然后拿这个空穴的父亲与要插入的元素进行比较,如果要插入的元素要小一点,那么这个空穴的父亲与空穴互换位置,一直进行,直到有一个数小于要插入元素或者空穴到达根节点,那么就将要插入元素插入到空穴所在位置,这种方法叫做**上滤法**,对于在索引为0的地方存储一个**足够小的值**,以至于堆里面任何一个值都大于它,当空穴到达索引为1的地方时,会与这个值进行比较,由于InsertElement大于这个值,所以循环会退出.然后再将新的最小值赋给索引为1的位置  
其实还有一种方法就是直接先把InsertElemnet赋给新开的空穴,但这样的话,每次向上交换时会产生三次赋值操作,如果使用空穴的话就只会有一次赋值.而且,数组第一个元素足够小保证了不需要判断条件就可以退出  
平均时间复杂度为O(logN)

### 删除最小元素

与插入的思想差不多,找到最小元素是很容易的,将根节点视为空穴,并且提取出最后一个元素lastkey,作为插入在最终空穴的位置上.进行下滤,每次下滤都是走两个儿子中小的那一边,然后将小儿子的关键字和该节点的关键字进行互换,然后就是判断提取出来的最后一个元素能不能插入在当前位置,也就是lastkey的值一定要比两个儿子的值都要小,否则就继续下滤.  
有一个麻烦的地方在于,有可能删除lastkey之后,有一个节点只有一个儿子,无法进行左右儿子的比较,解决的办法是:

> 如果需要用到这个节点的儿子,那么一定是左儿子,而且,一定是这个堆的最后一个元素,所以就可以通过判断是不是最后一个元素,来决定要不要进行左右儿子的比较,不进行比较的话,也就是说默认走的路就是左儿子那条路,也就是child的默认值是2*i

### 减小一个位置上的关键字的值

就先减小一个位子上的值,然后进行上滤

### 增大一个位置上的关键字的值

增大一个位子上的值,然后进行下滤

### 给一个用数组表示的完全二叉树,将其变成二叉堆

主要就是从中间节点开始下滤,一直进行到这个节点满足堆的堆序型,然后接着堆中间节点的下一个元素重复之前的下滤过程,直至遍历到数组的第一个元素

## 应用

### 选择问题--找出N个数中第k个最大的数

这里给出两种算法,当k=N/2的时候,二者的复杂度均为O(NlogN),相比于一般解法的O(N^2)有了不小的改进

#### 算法一

先将N个元素放入数组中,之后进行**buildheap**操作建立堆,这个操作最长时间是**O(NlogN)**,之后对这个堆进行k次**deletemin**操作,每次操作的时间是O(logN),所以总时间为**O(NlogN+klogN)**,

#### 算法二

一直维护一个含有k个元素的堆,这个堆里面最小的元素是**S(k)**,建立这样一个堆所需要的时间是 **O(klogk)** ,对于剩下的**N-k**个元素进行分别一个一个处理,对于每一个元素,都要比较与S(k)的关系,如果小于S(k),那么就舍弃,如果大于S(k),那么就删除原来的S(k)(进行一次**deletemin**操作),然后再把这个元素插入到堆中,更新S(k),总的操作时间为**O((N-k)logN)**,这样,当数组完全处理完之后,S(K)的值就是结果

## 左式堆

对于二叉堆而言,支持一次两个堆的合并操作所需要的时间是O(N),也就是将一个数组拷贝到另外一个数组中,但是这样有点慢了,但是基本上所有的高效的合并操作,都要用到指针,但是对指针的操作,又会使得堆对其他的操作变慢,最起码比对2做乘除法要慢  
对于左式堆,也有**结构特性和堆序性**,但是它不是平衡的,确切的说是非常不平衡  
左式堆的结构性质: 任意节点的NPL比它诸儿子的NPL的最小值多1,对于任意节点,其左儿子的NPL至少要跟右儿子的NPL一样大

> NPL就是当前节点到一个没有两个儿子的节点的最短路径,NULL节点的NPL是-1,只有一个儿子的节点或者没有儿子节点的NPL是0,

左式堆的特点:

1. 左儿子的NPL大于等于右儿子的NPL,
2. 不是平衡二叉树
3. 不能用数组来存储,
4. 也是一棵二叉树

### 操作

#### 合并-Merge

合并两个堆的操作一般都是使用递归实现,首先比较两个堆的根节点的大小,选择小的那个作为合并之后的堆的根节点,然后让小的根节点的右子树与大的根节点进行合并,小的根节点的左子树就是合并之后的左子树,之后又是上述过程,每次合并完成后,都要检查当前节点是不是满足左式堆的条件,不满足的话,一般让该节点的左右子树对调就行,然后再执行上一次递归,直至到达根节点.  
写递归的时候只需要考虑一般的情况和如何让递归退出

#### 插入-Insert

将插入看做一次合并,直接调用合并的函数就行

#### 删除最小-DeleteMIn

删除最小可以看成除去了根节点的两个堆的合并