# 散列(哈希表)

## 介绍

理想的散列表数据结构只不过是一个包含有_**关键字**_的具有固定大小的**数组**(假大小为tableSize)  
每一个关键字被映射到从0到tablesize-1这个范围中的某个数,这个映射就叫做_**散列函数**_,理想的散列函数应该把不同的关键字映射到不同单元,但这是不可能的,因此只可能做到尽可能均匀的分配关键字  
当两个关键字映射到同一个位置的时候,这种情况称为_**冲突**_

## 散列函数(哈希函数)

```.c
typedef unsigned int Index
```

几种常见的哈希函数

1. 如果关键字是数字,一般可以将**key mod tablesize**来作为该关键词的索引,但是这样和容易重复和空间浪费
2. 如果关键词是字符串,那么可以讲字符串各个字符的ascii码值加在一起然后 mod tablesize, 但是这种哈希函数的缺点是如果表特别大,不会很好的分配关键字,

    ```.c
    Index Hash(const char *str, int tablesize){
        unsigned int HashVal=0;

        while(*str!='\0)
            HashVal+=*str++;
        return HashVal % tablesize;
    }
    ```

3. 设计一个散列函数涉及到关键字的所有字符,并且可以分布的很好(但不一定是分布的最好的),但下面这种情况,如果关键字过长可以不使用全部字符,比如只使用奇数字

    ```.c
    Index Hash(const char *str, int tablesize){
        unsigned int HashVal=0;

        while(*str!='\0)
            HashVal=(HashVal<<5)+*str++;
        return HashVal % tablesize;
    }
    ```

剩下的问题就是解决当一个元素插入的时候,另外一个元素已经存在(两个元素的散列值相同),那么就产生一个冲突,冲突解决有两种方法:**分离链接法和开放定址法**

## 分离链接法

做法是将散列值相同的元素都保存到一个表里面,这些表是 _链表_,这些表都有表头,  
为了执行find:使用哈希函数找出应该查找哪个链表  
为了执行insert:使用Insert链表的方法,可以将新元素插入到一个链表的末位或者最前面,一般插入在最前面,因为最近插入的元素有可能最先被访问  
除了使用链表来解决冲突,还可以使用**二叉查找树**或者另外一个**哈希表**

### 装填因子

我们定义散列表的元素个数和散列表的大小的比值为装填因子(k),其实也就是哈希表每一个位置的**链表的平均长度**,  
一次成功的查找花费的时间为(k/2)+1  
一次不成功的查找花费时间为k,  
也就是说明链表的长度并不重要,装填因子才是最重要的,一般让**k尽可能等于1**才是最好的,因为这样查找的时间变得很短,而又不至于哈希表里有大量的空位,节省了空间  
其实也就是尽可能做到哈希表里面的元素尽可能**均匀分布**

## 开放定址法

分离链接法的主要缺点是需要用到指针,给指针分配空间会消耗时间,减慢算法速度  
所以这时就需要一个新的方法来解决冲突--开放定址法  
在这个方法里面,所有的数据都要存放在表里面,而不像上面那个方法,可以另外开一个链表,因此需要的空间很大  
对于这种方法,装添因子的大小应该低于k=0.5  

### 计算方法

一个关键字在哈希表里面的索引值: h(X)=(Hash(X)+F(i)) mod tablesize  
Hash(X)是哈希函数  
F(i)就是解决冲突的办法,下面来讨论几种

### 线性探测法

也就是F(i)是i的线性函数,最简单的就是H(i)=i,  
如果要插入的地方已经有元素,那么一直往这个索引后面的索引找(当查找到末尾的时候返回到最开始),直到找到一个不为空的位置,然后插入,虽然这样总能找到一个空单元去插入,但是所消耗的时间很多,并且如果表很空,那么元素所占据的单元也只会集中在很小的一块,这叫做 _一次聚集_,  
**随机冲突解决**: 对于查找,一次成功的查找消耗的时间比一次不成功查找消耗的时间要少,一次成功的查找可以看做是插入这个元素的时候一次不成功的查找,当一个哈希表从空一直插入的时候,装填因子是一直在上升的,随着装填因子的上升,后面的元素进行查找也就越来越难,哈希表里面空所占的比例为1-k,那么查找一个空单元预计的探测次数为1/(1-k),然后通过积分求平均的方式来得到平均值,  
对比随机冲突解决和线性探测法可以发现,线性探测法一般都要比随机冲突解决消耗的时间要更大

### 平方探测法

F(i)=i*i,对于线性探测,让表填满不是一个好主意,因为k越大,后面的查找和插入操作也就消耗的更长的时间,对于平方探测,当表的元素不是素数的时候,一旦表被填超过一半,平方探测可能找不到一个空位去插入,因此就有了下面的定理  
**定理**:如果使用平方探测,并且表的大小是**素数**,那么当表**至少有一半是空**的时候,我们总能找到一个空位去插入  
对于这种解决冲突的方法,删除不能够用一般的删除,因为这个位置可能已经引起过其他元素的冲突,其他元素绕过他存在了别处,如果按照一般的删除,对于那些绕过他的元素查找就会出现问题,所以这里对于一个元素的删除是**懒惰删除**

### 双散列

就是把一个哈希表的散列函数应用到另外一个哈希表里面,即`F(i)=i*hash2(X)`,也就是下一步探测的是加上i乘以关键字在另外一个哈希函数上的返回值  
在这种情况下,散列表的大小是**素数**很关键,

* 因为要保证所有单元都可以被检测到,
* 保证当一个位置产生冲突后,备选的位置不止一个

一个好的第二个哈希函数的例子是:`hash(X)=R-(X mod R)`,R可以取整数

## 再散列

对于使用平方探测法的开放定址散列法,如果哈希表过满(填充超过一半),那么插入一个元素就有可能不成功,或者花费的时间过长  

### 解决方法

我们可以建立一个大小是原来两倍的哈希表(这里的两倍指的是原来表大小两倍后的第一个素数,因为要保证表的大小是一个素数),然后遍历原来的表,并计算原来表中所有未删除的值在新表中的散列值(使用新表的散列函数),然后将这些元素放进新的表中,这个过程就叫做**再散列**  
这个算法的运行时间大约为O(N),因为有N个元素要再散列(考虑原始表的最大值)  
还有在再散列之前,已经对老表进行了N/2次插入,这之后,将老表的元素添加到新表里面的时候,每个元素所消耗的时间大约都是常数时间,因为TableSize变大,可能造成的冲突被减少了  
**有三种选择进行再散列**

* 当一次插入失败的时候
* 当插入到表元素一半的时候
* 当装填因子k达到某个值的时候