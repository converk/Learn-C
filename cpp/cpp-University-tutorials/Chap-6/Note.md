# 函数与递归

## 枚举类型

在枚举定义中任何枚举常量都可以被赋予一个整数值,其后的每个枚举常量的值是列表中前一个枚举常量的值加上1,直到下一个显式的设置为止。

```.cpp
enum status { Continue,
    Lose = 5,
    Win }; //创建枚举类型
cout << Continue << Lose << Win << endl;
```

三个类型的值依次为0,5,6,默认从0开始  

### C++11作用域限定的枚举类型

多个枚举类型可能包含相同的标识符。因此,在同一个程序中若使用这些枚举类型会导致命名冲突和逻辑错误  
C ++11引人了所谓的作用域限定的枚举类型,这种类型用关键字 enum class (或 enum struct )来声明

```.cpp
enum status { Continue,
    Lose = 5,
    Win }; //创建枚举类型
```

可以声明为

```.cpp
enum class Status
{
CONTINUE, WON, LOST
};
```

现在,如果要引用一个作用域限定的枚举常量,就必须像 `Status :: CONTINUE` —样,用作用域限定的枚举
类型名( Status )和作用域分辨运算符(::)来限定该常量。这样的话,显式地指定了
`CONTINUE` 是 `enum class Status` 作用域中的一个常量。

### C++11指定枚举常量的类型

在枚举类型名称后跟随一个冒号(:)和指定的整型类型。例如,我们可以指定 enum
常量应当具有的数据类型是 `unsigned int` ,具体采用如下形式:
`enum class Status : unsigned int { CONTINUE, WON, LOST };`

## 存储类型与存储周期

存储类别说明符:auto 、 register 、 extern 、 mutable 和 static

存储期:标识符的存储期决定了标识符在内存中存在的时间,存储类别说明符可以划分为四个存储期:自动存储期、静态存储期、动态存储期和线程存储期。  
  
作用域:标识符的作用域是指标识符在程序中可以被引用的范围。有些标识符在整个程序中都能被引用,有些只能限于在程序的某个部分引用  
作用域和存储期不一样

### 自动存储期和局部变量

具有自动存储期的变量包括:

* 声明在函数中的局部变量
* 函数的形参
* 用 register 声明的局部变量或函数形参

这样的变量在程序执行到定义它们的语句块时被创建,在语句块活动的时候它们是存在的,而当程序退出语句块时它们被销毁。自动变量只存在于其定义所在的函数体中**最接近它的花括号对**内,或者当它是函数形参时,则存在于整个函数体中。**局部变量默认情况下具有自动存储期**

### 静态存储期

关键字 `extern` 和 `static` 为函数和具有静态存储期的变量声明标识符。具有静态存储期的变量从程序开始执行的时刻起直至程序执行结束,一直存在于内存中。在遇到这样的变量声明时,便对它进行一次性初始化。对于函数而言,在程序开始执行时函数名存在。然而,**即使函数名和静态存储期变量在程序一开始执行时就存在,也并不意味着这些标识符在整个程序中都能使用**

#### 标识符

有两种具有静态存储期的标识符--**外部标识符(例如全局变量)**和**用存储类别说明符 static 声明的局部变量**。全局变量是通过把变量声明放在任何类或者函数定义外部来创建的。全局变量在整个程序执行过程中保存它们的值。全局变量和全局函数可以被源文件中位于其声明或者定义之后的任何函数引用。

#### 静态局部变量

使用关键字 static 声明的局部变量仅被其声明所在的函数所知(只有声明的函数才可以使用这个变量),**如果程序员没有显式地初始化具有静态存储期的数值变量,那么它们被默认地初始化为0。**。但是,与自动变量不同的是, static局部变量在函数返回到它的调用者后仍保留着它们的值。下次再调用函数时, static 局部变量包含的是该函数最后一次执行得到的值。下面的语句将局部变量 count 声明为 static 并且初始化为1 :

```.cpp
static unsigned int count = 1;
```

## 作用域规则

### 语句块作用域

在一个语句块中声明的标识符具有语句块作用域。该作用域开始于标识符的声明处,结束于标识符声明所在语句块的束右花括号处。局部变量具有语句块作用域,函数形参同样具有语句块作用域。任何语句块都能包含变量声明。**当语句块是嵌套的并且外层语句块中的一个标识符与内层语句块中的一个标识符具有相同的名字时,外层语句块的标识符处于“隐藏”状态,直到内层语句块的执行结束为止**。内层语句块看到的是它自己的局部标识符的值,而不是包含它的语句块中同名标识符的值。**声明为 static 的局部变量仍然具有语句块作用域,虽然它们从程序开始执行时就一直存在。存储期并不影响标识符的作用域.**

### 全局命名空间作用域

**声明于任何函数或者类之外的标识符**具有全局命名空间作用域,这种标识符对于从其声明处开始直到文件结尾处为止出现的所有函数而言都是“已知”的,即可访问的。位于函数之外的全局变量、函数定义和函数原型都具有全局命名空间作用域。

### 函数原型作用域

具有函数原型作用域的唯一标识符是那些用在函数原型形参列表中的标识符。如前所述,函数原型的形参列表不需要形参名,只需要它们的类型。函数原型的形参列表中出现的名字会被编译器所忽略。用**在函数原型中的标识符可以在程序中的任何地方无歧义地复用。**

## 值传递,引用传递和地址传递

值传递和指针传递都是与C语言里面一样的一样的

### 引用传递

利用按引用传递,调用者使被调用函数可以直接访问调用者的数据,并且可以修改这些数据。  
引用形参是函数调用中相应实参的别名。为了指明一个函数形参是按引用传递的,只要简单地在函数原型中形参类型后加一个&标识即可  
在函数调用中,简单地**用变量的名字**(而不是像指针传递那样取地址)来对它进行按引用的传递,然后,在被调用函数的体内用变量的形参名(不是指针),这实际上引用的是调用函数中的原始变量,并且被调用函数可以直接修改这个原始变量

#### 在函数内引用作为别名

引用还可以在函数中用作其他变量的别名  

```.cpp
int m = 1;
int& n = m;
n++;
cout << m << endl;  //m为2
```

**引用变量必须在它们的声明中完成初始化并且不能再指定为其他变量的别名**一旦一个引用被声明为另一个变量的别名,在别名(即引用)上执行的所有操作实际上作用在原始变量上。

```.cpp
#include <iostream>

using namespace std;

void squear_by_value(int);   //值传递
void suqear_by_refer(int&);  //引用传递
void squear_by_point(int*);  //指针传递

int main()
{
    int x = 2;
    int y = 2;
    int z = 2;
    squear_by_point(&z);
    squear_by_value(x);
    suqear_by_refer(y);
    cout << "x: " << x << "y: " << y << "z: " << z << endl;
}

void squear_by_value(int a)
{
    a *= a;
}

void suqear_by_refer(int& a)
{
    a *= a;
}

void squear_by_point(int* a)
{
    *a *= *a;
}
```

## 默认实参

默认实参必须是函数形参列表中最靠右边(尾部)的实参。当调用具有两个或者更多个默认实参的函数时,如果省略的实参不是实参列表中最靠右边的实参,那么该实参右边的所有实参也必须被省略。**默认实参应该在函数名第一次出现时指定**,通常是在函数原型中。如果因为函数定义也作为函数原型而省略了函数原型,那么默认实参应该在函数头部中指定。默认值可以是任何表达式,包括常量、全局变量或者函数调用。  
显式地传递给函数的任何实参都按**从左到右**的顺序赋值给了函数的形参

## 一元作用域分辨运算符

当局部变量和全局变量被声明为相同的名字的时候,使用一元作用域分辨运算符可以在同名的局部变量的作用域内访问**全局变量**,不能使一元的作用域分辨运算符访问外层语句块中**具有相同名字的局部变量(包括带有static标识符的也不能访问,因为是局部变量)**。如果全局变量和作用域中的局部变量的名字不同,那么不用一元的作用域分辨运算符就可以直接访问全局变量。

```.cpp
#include <iostream>

using namespace std;

int number = 7;

int main()
{
    double number = 8.8;
    static int first = 9;
    int second = 5;
    cout << "local_number: " << number << endl;
    cout << "golab_number: " << ::number << endl;
    {
        double first = 9.9;
        float number = 1.1;
        cout << "local: " << first << endl;
        cout << "local: " << second << endl; //直接打印上一个作用域的变量,因为这个作用域没有这个变量
        //cout << "gloab: " << ::first << endl; //这么写会报错,不可以用来识别局部变量
        cout << "local_number: " << number << endl; //输出当前作用域的的number值(1.1)
        cout << "golab_number: " << ::number << endl; //输出全局的number值(7)
    }
    return 0;
}
```

## 函数重载

C++允许定义多个具有相同名字的函数,只要这些函数具有不同的函数签名.这种特性称为 **函数重载**.当调用一个重载函数时, C++编译器通过检查函数调用中的**实参数目、类型和顺序**来选择恰当的函数.函数重载通常用于创建执行相似任务、但是作用于不同的数据类型的具有相同名字的多个函数

```.cpp
void square(int x)
{
    cout << "the square of int " << x * x << endl;
}

void square(double x)
{
    cout << "the square of double " << x * x << endl;
}

int main()
{
    square(4);  //16
    square(2.5);  //6.5
    return 0;
}
```

重载的函数通过它们的签名来区分. 签名由函数的名字和它的形参类型(按顺序)组成,  
**当两个函数的函数名和形参列表都一样,但是返回类型不一样,那么编译器会报错,因为编译器不检查返回类型**  
main函数不能被重载

## 函数模板

重载函数通常用于执行相似的操作,这些操作涉及作用于不同数据类型上的不同程序逻辑。如果对于每种数据类型程序逻辑和操作都是相的,那么使用函数模板可以使重载执行起来更加紧凑和方便  
需要编写单个函数模板定义。只有在这个模板函数调用中提供了实参类型,C ++就会自动生成独立的函数模板特化  
所有的函数模板定义都以 **template** 关键字幵头,后面跟着用一对尖括号(<和>)括起的该函数模板的模板形参列表。模板形参列表中的每个形参(常常称作形式类型形参)由关键字 `typename` 或者关键字 `class`开头。**形式类型形参**是基本类型或者用户自定义类型的占位符。这些占位符用于**指定函数形参的类型**,**指定函数的返回类型**,**以及在函数定义体内声明变量**.函数模板的定义与其他函数的定义一样,只是使用形式类型形参作为实际数据类型的占位符

```.cpp
template < typenane T > // or tempiate< class T >
T maximum(T valuel, T va1ue2, T value3 ){
    T maximumValue = valuel;

if (value2 > maximumValue)
    maximumValue = va1ue2;
if (va1ue3 > maximumValue )
    maximumValue = value3;
return maximumValue;
```

当编译器在程序源代码中检测到 maximum 调用时,传递给 maximum 的数据类型代替整个模板定义中的 T ,并且为了确定给定数据类型的三个值中的最大值, C++会创建一个完整的函数。  
要注意调用这个模板的函数时,实参的数据类型必须与形参的数据类型完全一样,比如如果形参是int,那么不能传进去一个double,不会进行隐式类型转换,会发出警告,或者在调用的时候使用stat_cast<int>进行强制转换